<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>Simplex KKT - Interativo (corrigido)</title>
<style>
  body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f6f9fc; color:#0b2545; }
  h1{margin-bottom:6px;}
  .card{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(11,37,69,0.06);margin-bottom:12px}
  label{display:inline-block;margin-right:10px}
  input[type=number], input[type=text]{width:95px;padding:6px;border:1px solid #cbd5e1;border-radius:6px}
  button{padding:8px 12px;border-radius:6px;border:none;background:#2563eb;color:#fff;cursor:pointer;margin-right:6px}
  button.ghost{background:#64748b}
  table{border-collapse:collapse;margin-top:8px;width:100%}
  th,td{border:1px solid #e2e8f0;padding:6px;text-align:center;font-size:13px}
  caption{font-weight:bold;margin-bottom:6px;text-align:left}
  .status{margin-top:10px;padding:8px;border-radius:6px}
  .ok{background:#ecfccb;color:#14532d}
  .err{background:#fee2e2;color:#7f1d1d}
  .prevTable input{background:#f3f4f6;border-color:#e2e8f0}
  .note{font-size:13px;color:#334155;margin-top:8px}
  #finalScore{font-weight:bold;margin-top:12px}
</style>
</head>
<body>

<h1>Simplex KKT - Quadrático Interativo</h1>

<div class="card">
  <div class="small">Informe os coeficientes da função objetivo (maximizar):</div>
  <div style="margin-top:8px">
    <label>coef x1²: <input id="c_x1sq" type="number" step="any" value="-1"></label>
    <label>coef x2²: <input id="c_x2sq" type="number" step="any" value="-2"></label>
    <label>coef x1x2: <input id="c_x1x2" type="number" step="any" value="0"></label>
    <label>coef x1: <input id="c_x1" type="number" step="any" value="6"></label>
    <label>coef x2: <input id="c_x2" type="number" step="any" value="8"></label>
  </div>

  <div style="margin-top:10px" class="small">Restrição linear (≤):</div>
  <div style="margin-top:8px">
    <label>a1 (x1): <input id="a1" type="number" step="any" value="2"></label>
    <label>a2 (x2): <input id="a2" type="number" step="any" value="4"></label>
    <label>b: <input id="b" type="number" step="any" value="8"></label>
  </div>

  <div class="note">Observação: as restrições <b>x1 ≥ 0</b> e <b>x2 ≥ 0</b> são implícitas (não precisam ser digitadas).</div>

  <div style="margin-top:12px">
    <button id="start">Iniciar Iterações</button>
    <button id="restart" class="ghost" style="display:none">Reiniciar</button>
  </div>
</div>

<div id="iterationsArea" class="card" style="display:none"></div>

<div id="feedback" class="status" style="display:none"></div>
<div id="finalScore"></div>

<script>
// ---------- util ----------
function numFrom(id, fallback=0){
  const v = parseFloat(document.getElementById(id).value);
  return Number.isFinite(v) ? v : fallback;
}
function fmt(x){ return (Math.abs(x) < 1e-12) ? '0' : Number(x).toFixed(6); }

// ---------- variáveis globais ----------
const varNames = ['x1','x2','x3','y1','y2','y3'];
let base = ['x3','y1','y2'];
let A = [];
let b = [];
let autoIterations = []; // { base, A, b }
let currentIter = 0;
let score = 0, totalChecks = 0;

// ---------- monta A e b automaticamente a partir dos inputs ----------
function montarProblema() {
  const c_x1sq = numFrom('c_x1sq');
  const c_x2sq = numFrom('c_x2sq');
  const c_x1   = numFrom('c_x1');
  const c_x2   = numFrom('c_x2');
  const c_x1x2 = numFrom('c_x1x2');
  const a1 = numFrom('a1');
  const a2 = numFrom('a2');
  const bb = numFrom('b');

  // monta exatamente como você definiu
  A = [
    [ a1, a2, 1, 0, 0, 0 ],
    [ 2 * c_x1sq, c_x1x2, 0, 1, 0, -a1 ],
    [ 0, 2 * c_x2sq, 0, 0, 1, -a2 ]
  ];

  b = [ bb, -c_x1, -c_x2 ];

  return { A, b };
}

// ---------- manipulação de iterações (igual à sua lógica original) ----------
function saveAutoIteration(){
  autoIterations.push({
    base:[...base],
    A: A.map(row => row.slice()),
    b: b.slice()
  });
}

function pivot(row, col){
  const pv = A[row][col];
  if (Math.abs(pv) < 1e-12) { console.warn('pivot zero'); return; }
  // normaliza linha do pivot
  for (let j=0;j<A[row].length;j++) A[row][j] /= pv;
  b[row] /= pv;
  // elimina nas outras linhas
  for (let i=0;i<A.length;i++){
    if (i===row) continue;
    const factor = A[i][col];
    for (let j=0;j<A[i].length;j++) A[i][j] -= factor * A[row][j];
    b[i] -= factor * b[row];
  }
  base[row] = varNames[col];
  saveAutoIteration();
}

function enteringVar(){
  // regra que você usava: escolhe linha com b negativo (mais negativo)
  let minVal = 0, row = -1;
  for (let i=0;i<b.length;i++){
    if (b[i] < minVal){ minVal = b[i]; row = i; }
  }
  if (row === -1) return null;
  const leaveVar = base[row];
  const enterVar = leaveVar.startsWith('x') ? 'y'+leaveVar.slice(1) : 'x'+leaveVar.slice(1);
  const col = varNames.indexOf(enterVar);
  return { row, col };
}

function isOptimal(){
  return b.every(v => v >= -1e-9);
}

function solveAutomatic(){
  montarProblema();
  base = ['x3','y1','y2'];
  autoIterations = [];
  saveAutoIteration();
  // cópia defensiva das matrizes já feita no saveAutoIteration
  // loop de pivoteamento
  let safety=0;
  while (!isOptimal() && safety < 50){
    const pv = enteringVar();
    if (!pv) break;
    pivot(pv.row, pv.col);
    safety++;
  }
  // se safety estourar, paramos (evita loop infinito)
}

// ---------- renderização das tabelas ----------

function renderStudentIteration(idx){
  const area = document.getElementById('iterationsArea');
  area.style.display = 'block';
  area.innerHTML = ''; // sempre re-renderiza: prev + atual

  // prev (readonly) se houver
  if (idx > 0){
    const prev = autoIterations[idx-1];
    const tblPrev = document.createElement('table');
    tblPrev.className = 'prevTable';
    tblPrev.innerHTML = `<caption>Iteração ${idx} (anterior - somente consulta)</caption>`;
    const trh = document.createElement('tr');
    trh.innerHTML = '<th>Base</th>' + varNames.map(v => `<th>${v}</th>`).join('') + '<th>b</th>';
    tblPrev.appendChild(trh);
    for (let r=0; r<prev.base.length; r++){
      const tr = document.createElement('tr');
      // cada célula com input readonly para facilitar leitura
      let rowHtml = `<td><input type="text" value="${prev.base[r]}" readonly></td>`;
      for (let j=0;j<varNames.length;j++){
        rowHtml += `<td><input type="text" value="${fmt(prev.A[r][j])}" readonly></td>`;
      }
      rowHtml += `<td><input type="text" value="${fmt(prev.b[r])}" readonly></td>`;
      tr.innerHTML = rowHtml;
      tblPrev.appendChild(tr);
    }
    area.appendChild(tblPrev);
  }

  // atual -- editável
  const it = autoIterations[idx];
  const tbl = document.createElement('table');
  tbl.innerHTML = `<caption>Iteração ${idx+1} (preencha os valores)</caption>`;
  const trh = document.createElement('tr');
  trh.innerHTML = '<th>Base</th>' + varNames.map(v => `<th>${v}</th>`).join('') + '<th>b</th>';
  tbl.appendChild(trh);
  for (let r=0;r<it.base.length;r++){
    const tr = document.createElement('tr');
    let rowHtml = `<td><input id="base_${r}" type="text" placeholder="${it.base[r]}"></td>`;
    for (let j=0;j<varNames.length;j++){
      rowHtml += `<td><input id="cell_${r}_${j}" type="text" placeholder="${fmt(it.A[r][j])}"></td>`;
    }
    rowHtml += `<td><input id="b_${r}" type="text" placeholder="${fmt(it.b[r])}"></td>`;
    tr.innerHTML = rowHtml;
    tbl.appendChild(tr);
  }
  area.appendChild(tbl);

  // botões (verificar)
  const btn = document.createElement('button');
  btn.innerText = 'Verificar Iteração';
  btn.onclick = () => checkIteration(idx);
  area.appendChild(btn);

  // botão reiniciar visível
  document.getElementById('restart').style.display = 'inline-block';
}

// ---------- verificação e pontuação ----------
function checkIteration(idx){
  const it = autoIterations[idx];
  let correct = true;
  // percorre células e compara
  for (let r=0;r<it.base.length;r++){
    const bas = (document.getElementById(`base_${r}`).value || '').trim();
    if (bas !== it.base[r]) correct = false;
    for (let j=0;j<varNames.length;j++){
      const raw = (document.getElementById(`cell_${r}_${j}`).value || '').trim();
      // aceita fração "a/b" ou número com ponto/virgula
      let val = NaN;
      if (raw.includes('/')){
        const parts = raw.split('/');
        val = parseFloat(parts[0]) / parseFloat(parts[1]);
      } else {
        val = parseFloat(raw.replace(',', '.'));
      }
      if (!Number.isFinite(val)) { correct = false; continue; }
      if (Math.abs(val - it.A[r][j]) > 1e-4) correct = false;
    }
    const rawb = (document.getElementById(`b_${r}`).value || '').trim();
    let bv = NaN;
    if (rawb.includes('/')){
      const parts = rawb.split('/');
      bv = parseFloat(parts[0]) / parseFloat(parts[1]);
    } else {
      bv = parseFloat(rawb.replace(',', '.'));
    }
    if (!Number.isFinite(bv) || Math.abs(bv - it.b[r]) > 1e-4) correct = false;
  }

  totalChecks++;
  if (correct) score++;

  // feedback e próximo passo
  const fb = document.getElementById('feedback');
  fb.style.display = 'block';
  if (correct){
    fb.className = 'status ok';
    fb.innerText = '✅ Iteração correta!';
    // avança
    currentIter++;
    if (currentIter < autoIterations.length){
      renderStudentIteration(currentIter);
    } else {
      // terminou todas
      const nota = totalChecks > 0 ? Math.max(1, Math.round(100 * score / totalChecks)) : 0;
      fb.innerText = `✅ Todas as iterações preenchidas. Nota final: ${nota}/100`;
      document.getElementById('finalScore').innerText = `Nota final: ${nota}/100`;
    }
  } else {
    fb.className = 'status err';
    fb.innerText = '❌ Iteração incorreta. Revise os valores (use o tableau anterior como referência).';
  }
}

// ---------- eventos ----------
document.getElementById('start').addEventListener('click', ()=>{
  // montar e resolver
  solveAutomatic();
  // reset pontuação e iteradores
  score = 0; totalChecks = 0; currentIter = 0;
  // limpar área, mostrar primeira iteração
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  renderStudentIteration(currentIter);
});

document.getElementById('restart').addEventListener('click', ()=>{
  // voltar ao início para permitir editar coeficientes e reiniciar
  autoIterations = [];
  A = []; b = [];
  base = ['x3','y1','y2'];
  currentIter = 0; score = 0; totalChecks = 0;
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  // esconde restart até nova execução
  document.getElementById('restart').style.display = 'none';
});

// ---------- função que resolve automático e popula autoIterations ----------
function solveAutomatic(){
  montarProblema();
  base = ['x3','y1','y2'];
  autoIterations = [];
  saveAutoIteration();
  // pivoteamento automático (mesma lógica)
  let safety = 0;
  while (!isOptimal() && safety < 50){
    const pv = enteringVar();
    if (!pv) break;
    pivot(pv.row, pv.col);
    safety++;
  }
}
</script>
</body>
</html>
